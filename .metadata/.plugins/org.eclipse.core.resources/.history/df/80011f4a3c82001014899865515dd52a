package com.skrrrrr.harudam.verification;

import com.skrrrrr.harudam.auth.AuthCode;
import com.skrrrrr.harudam.auth.AuthCodeRepository;
import com.skrrrrr.harudam.common.enums.AuthCodeStatus;
import com.skrrrrr.harudam.member.ChildUser;
import com.skrrrrr.harudam.member.ChildUserRepository;
import com.skrrrrr.harudam.member.ParentUser;
import com.skrrrrr.harudam.member.ParentUserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.security.SecureRandom;
import java.time.ZonedDateTime;
import com.skrrrrr.harudam.verification.AlimtalkSender;


@Service
@RequiredArgsConstructor
public class VerificationService {

    private static final int CODE_LENGTH = 6;
    private static final int TTL_SECONDS = 180;
    private static final SecureRandom RNG = new SecureRandom();

    private final AuthCodeRepository authCodeRepository;
    private final ChildUserRepository childUserRepository;
    private final ParentUserRepository parentUserRepository;
    private final AlimtalkSender alimtalkSender; // 구현체는 나중에 추가해도 됨 (인터페이스만 우선)

    @Transactional
    public void sendCode(Long childId, String parentPhone) {
        ChildUser child = childUserRepository.findById(childId)
                .orElseThrow(() -> new IllegalArgumentException("자녀를 찾을 수 없습니다. id=" + childId));

        String normalized = parentPhone.replaceAll("\\D", "");

        authCodeRepository.findAll().stream()
                .filter(c -> normalized.equals(c.getTargetParentPhone()))
                .filter(c -> c.getStatus() == AuthCodeStatus.ISSUED)
                .forEach(c -> c.setStatus(AuthCodeStatus.EXPIRED));

        String code = generate();
        ZonedDateTime now = ZonedDateTime.now();

        AuthCode ac = new AuthCode();
        ac.setCodeValue(code);
        ac.setIssuedByChild(child);
        ac.setTargetParentPhone(normalized);
        ac.setStatus(AuthCodeStatus.ISSUED);
        ac.setExpiresAt(now.plusSeconds(TTL_SECONDS));

        // 실제 전송은 어댑터로 위임 (나중에 카카오 알림톡 붙임)
        alimtalkSender.sendVerificationCode(normalized, code, TTL_SECONDS);

        authCodeRepository.save(ac);
    }

    @Transactional
    public boolean verifyCode(String parentPhone, String code) {
        String normalized = parentPhone.replaceAll("\\D", "");

        AuthCode target = authCodeRepository.findAll().stream()
                .filter(c -> normalized.equals(c.getTargetParentPhone()))
                .filter(c -> c.getStatus() == AuthCodeStatus.ISSUED)
                .reduce((a,b)->b).orElse(null);

        if (target == null) return false;
        if (ZonedDateTime.now().isAfter(target.getExpiresAt())) {
            target.setStatus(AuthCodeStatus.EXPIRED);
            return false;
        }
        if (!target.getCodeValue().equals(code)) return false;

        target.setStatus(AuthCodeStatus.USED);
        target.setUsedAt(ZonedDateTime.now());

        // 부모 엔티티 없으면 생성(전화번호만)
        parentUserRepository.findByPhone(normalized).orElseGet(() -> {
            ParentUser p = new ParentUser();
            p.setPhone(normalized);
            return parentUserRepository.save(p);
        });

        return true;
    }

    private String generate() {
        StringBuilder sb = new StringBuilder(CODE_LENGTH);
        for (int i=0;i<CODE_LENGTH;i++) sb.append(RNG.nextInt(10));
        return sb.toString();
    }
}

[file 패키지]

package com.skrrrrr.harudam.file;

import org.springframework.stereotype.Service;

import java.io.*;
import java.nio.file.*;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

/**
 * 부모의 voice 폴더 압축 & 정리 서비스
 * - parent/{parentId}/voice 폴더만 압축
 * - 압축 후 voice 폴더 삭제
 */
@Service
public class CompressionService {

    private final FileStorageProperties properties;

    public CompressionService(FileStorageProperties properties) {
        this.properties = properties;
    }

    /**
     * 특정 parentId 의 voice 폴더를 압축 후 삭제
     * @param parentId 부모 ID
     * @return 생성된 zip 파일 경로
     */
    public Path compressAndCleanupParentVoice(Long parentId) throws IOException {
        Path voiceDir = properties.getUploadPath()
                .resolve("parent")
                .resolve(parentId.toString())
                .resolve("voice");

        if (!Files.exists(voiceDir)) {
            throw new FileNotFoundException("voice 폴더가 존재하지 않습니다: " + voiceDir);
        }

        // 압축 파일 경로: parent/{parentId}_voice.zip
        Path parentDir = voiceDir.getParent(); // parent/{parentId}
        Path zipPath = parentDir.resolve(parentId + "_voice.zip");

        try (ZipOutputStream zos = new ZipOutputStream(Files.newOutputStream(zipPath))) {
            Files.walk(voiceDir)
                    .filter(path -> !Files.isDirectory(path))
                    .forEach(path -> {
                        ZipEntry zipEntry = new ZipEntry(voiceDir.relativize(path).toString());
                        try {
                            zos.putNextEntry(zipEntry);
                            Files.copy(path, zos);
                            zos.closeEntry();
                        } catch (IOException e) {
                            throw new UncheckedIOException(e);
                        }
                    });
        }

        // voice 폴더 삭제
        deleteDirectoryRecursively(voiceDir);

        return zipPath;
    }

    // ---------------- 내부 유틸 ----------------

    private void deleteDirectoryRecursively(Path dir) throws IOException {
        if (!Files.exists(dir)) return;

        Files.walk(dir)
                .sorted((a, b) -> b.compareTo(a)) // 파일 → 디렉토리 순으로
                .forEach(path -> {
                    try {
                        Files.deleteIfExists(path);
                    } catch (IOException e) {
                        throw new UncheckedIOException(e);
                    }
                });
    }
}

----
package com.skrrrrr.harudam.file;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.nio.file.Path;
import java.util.Map;

@RestController
@RequestMapping("/api/files")
public class FileController {

    private final FileStorageService fileStorageService;
    private final CompressionService compressionService;

    public FileController(FileStorageService fileStorageService,
                          CompressionService compressionService) {
        this.fileStorageService = fileStorageService;
        this.compressionService = compressionService;
    }

    // -------------------- 자녀 --------------------

    @PostMapping("/child/{childId}/picture")
    public ResponseEntity<?> uploadChildPicture(
            @PathVariable Long childId,
            @RequestParam("file") MultipartFile file) throws IOException {
        Path saved = fileStorageService.saveChildPicture(childId, file);
        return ResponseEntity.ok(Map.of("path", saved.toString()));
    }

    @PostMapping("/child/{childId}/voice")
    public ResponseEntity<?> uploadChildVoice(
            @PathVariable Long childId,
            @RequestParam("file") MultipartFile file) throws IOException {
        Path saved = fileStorageService.saveChildVoice(childId, file);
        return ResponseEntity.ok(Map.of("path", saved.toString()));
    }

    // -------------------- 부모 --------------------

    @PostMapping("/parent/{parentId}/picture")
    public ResponseEntity<?> uploadParentPicture(
            @PathVariable Long parentId,
            @RequestParam("file") MultipartFile file) throws IOException {
        Path saved = fileStorageService.saveParentPicture(parentId, file);
        return ResponseEntity.ok(Map.of("path", saved.toString()));
    }

    @PostMapping("/parent/{parentId}/voice/{chatNumber}")
    public ResponseEntity<?> uploadParentVoice(
            @PathVariable Long parentId,
            @PathVariable int chatNumber,
            @RequestParam("file") MultipartFile file) throws IOException {
        Path saved = fileStorageService.saveParentVoice(parentId, file, chatNumber);
        return ResponseEntity.ok(Map.of("path", saved.toString()));
    }

    // -------------------- 부모 voice 압축 --------------------

    /** 부모 voice 폴더 압축 */
    @PostMapping("/parent/{parentId}/voice/compress")
    public ResponseEntity<?> compressParentVoice(@PathVariable Long parentId) throws IOException {
        Path zipPath = compressionService.compressAndCleanupParentVoice(parentId);
        return ResponseEntity.ok(Map.of(
                "message", "voice 폴더 압축 완료",
                "zipPath", zipPath.toString()
        ));
    }

    // -------------------- AI 학습 결과 --------------------

    @PostMapping("/child/{childId}/ai/picture")
    public ResponseEntity<?> saveAiChildPicture(
            @PathVariable Long childId,
            @RequestBody byte[] data) throws IOException {
        Path saved = fileStorageService.saveAiChildPicture(childId, data, ".jpg");
        return ResponseEntity.ok(Map.of("path", saved.toString()));
    }

    @PostMapping("/child/{childId}/ai/voice")
    public ResponseEntity<?> saveAiChildVoice(
            @PathVariable Long childId,
            @RequestBody byte[] data) throws IOException {
        Path saved = fileStorageService.saveAiChildVoice(childId, data, ".mp3");
        return ResponseEntity.ok(Map.of("path", saved.toString()));
    }

    @PostMapping("/parent/{parentId}/ai/picture")
    public ResponseEntity<?> saveAiParentPicture(
            @PathVariable Long parentId,
            @RequestBody byte[] data) throws IOException {
        Path saved = fileStorageService.saveAiParentPicture(parentId, data, ".jpg");
        return ResponseEntity.ok(Map.of("path", saved.toString()));
    }

    @PostMapping("/parent/{parentId}/ai/voice")
    public ResponseEntity<?> saveAiParentVoice(
            @PathVariable Long parentId,
            @RequestBody byte[] data) throws IOException {
        Path saved = fileStorageService.saveAiParentVoice(parentId, data, ".mp3");
        return ResponseEntity.ok(Map.of("path", saved.toString()));
    }

    // -------------------- 에러 처리 --------------------

    @ExceptionHandler(IOException.class)
    public ResponseEntity<?> handleIOException(IOException e) {
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(Map.of("error", "파일 저장 실패", "message", e.getMessage()));
    }
}

----
package com.skrrrrr.harudam.file;

import java.nio.file.Path;
import java.nio.file.Paths;

import org.springframework.boot.context.properties.ConfigurationProperties;

/**
 * 파일 저장소의 베이스 디렉터리를 주입받는 설정 클래스.
 * application.properties 의 `file.upload-dir` 값을 사용한다.
 *
 * 예) file.upload-dir=C:/desktop/project/skrrrrr/uploads
 */
@ConfigurationProperties(prefix = "file")
public class FileStorageProperties {

    /**
     * 설정에서 주입받는 원본 문자열 경로.
     */
    private String uploadDir;

    /**
     * 정규화된 절대경로(Path)로 반환.
     * 값이 비어있으면 프로젝트 루트 기준 ./uploads 를 기본값으로 사용.
     */
    public Path getUploadPath() {
        if (uploadDir == null || uploadDir.isBlank()) {
            return Paths.get("uploads").toAbsolutePath().normalize();
        }
        // ~ 치환 및 절대 경로 정규화
        String expanded = uploadDir.replace("~", System.getProperty("user.home"));
        return Paths.get(expanded).toAbsolutePath().normalize();
    }

    public void setUploadDir(String uploadDir) {
        this.uploadDir = uploadDir;
    }

    public String getUploadDir() {
        return uploadDir;
    }
}

-----
package com.skrrrrr.harudam.file;

import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.nio.file.*;
import java.util.UUID;

/**
 * 파일 저장 서비스.
 * - child / parent 구분
 * - 각 id 별 picture / voice 디렉토리 생성
 * - 파일명 규칙 적용
 * - 부모 음성(chat1 ~ chat30) 관리
 * - AI 학습 결과 파일명 규칙 지원 (자녀/부모 모두)
 */
@Service
public class FileStorageService {

    private final FileStorageProperties properties;

    public FileStorageService(FileStorageProperties properties) {
        this.properties = properties;
    }

    // ------------------- 원본 파일 저장 -------------------

    /** 자녀 사진 저장 */
    public Path saveChildPicture(Long childId, MultipartFile file) throws IOException {
        Path pictureDir = getChildDir(childId).resolve("picture");
        Files.createDirectories(pictureDir);

        String filename = childId + "_picture_" + UUID.randomUUID() + getExtension(file.getOriginalFilename());
        Path target = pictureDir.resolve(filename);
        file.transferTo(target);

        return target;
    }

    /** 자녀 목소리 저장 */
    public Path saveChildVoice(Long childId, MultipartFile file) throws IOException {
        Path voiceDir = getChildDir(childId).resolve("voice");
        Files.createDirectories(voiceDir);

        String filename = childId + "_voice_" + UUID.randomUUID() + getExtension(file.getOriginalFilename());
        Path target = voiceDir.resolve(filename);
        file.transferTo(target);

        return target;
    }

    /** 부모 사진 저장 */
    public Path saveParentPicture(Long parentId, MultipartFile file) throws IOException {
        Path pictureDir = getParentDir(parentId).resolve("picture");
        Files.createDirectories(pictureDir);

        String filename = parentId + "_picture_" + UUID.randomUUID() + getExtension(file.getOriginalFilename());
        Path target = pictureDir.resolve(filename);
        file.transferTo(target);

        return target;
    }

    /** 부모 목소리 저장 (chat1 ~ chat30) */
    public Path saveParentVoice(Long parentId, MultipartFile file, int chatNumber) throws IOException {
        if (chatNumber < 1 || chatNumber > 30) {
            throw new IllegalArgumentException("chat 번호는 1 ~ 30까지만 허용됩니다.");
        }

        Path voiceDir = getParentDir(parentId).resolve("voice");
        Files.createDirectories(voiceDir);

        String filename = parentId + "_chat" + chatNumber + ".mp3";
        Path target = voiceDir.resolve(filename);
        file.transferTo(target);

        return target;
    }

    // ------------------- AI 학습 결과 저장 -------------------

    /** 자녀 학습된 사진 저장 */
    public Path saveAiChildPicture(Long childId, byte[] data, String extension) throws IOException {
        Path pictureDir = getChildDir(childId).resolve("picture");
        Files.createDirectories(pictureDir);

        String filename = "ai_" + childId + "_picture_" + UUID.randomUUID() + extension;
        Path target = pictureDir.resolve(filename);
        Files.write(target, data);

        return target;
    }

    /** 자녀 학습된 목소리 저장 */
    public Path saveAiChildVoice(Long childId, byte[] data, String extension) throws IOException {
        Path voiceDir = getChildDir(childId).resolve("voice");
        Files.createDirectories(voiceDir);

        String filename = "ai_" + childId + "_voice_" + UUID.randomUUID() + extension;
        Path target = voiceDir.resolve(filename);
        Files.write(target, data);

        return target;
    }

    /** 부모 학습된 사진 저장 */
    public Path saveAiParentPicture(Long parentId, byte[] data, String extension) throws IOException {
        Path pictureDir = getParentDir(parentId).resolve("picture");
        Files.createDirectories(pictureDir);

        String filename = "ai_" + parentId + "_picture_" + UUID.randomUUID() + extension;
        Path target = pictureDir.resolve(filename);
        Files.write(target, data);

        return target;
    }

    /** 부모 학습된 목소리 저장 */
    public Path saveAiParentVoice(Long parentId, byte[] data, String extension) throws IOException {
        Path voiceDir = getParentDir(parentId).resolve("voice");
        Files.createDirectories(voiceDir);

        String filename = "ai_" + parentId + "_voice_" + UUID.randomUUID() + extension;
        Path target = voiceDir.resolve(filename);
        Files.write(target, data);

        return target;
    }

    // ---------------- 내부 헬퍼 메소드 ----------------

    private Path getChildDir(Long childId) {
        return properties.getUploadPath().resolve("child").resolve(childId.toString());
    }

    private Path getParentDir(Long parentId) {
        return properties.getUploadPath().resolve("parent").resolve(parentId.toString());
    }

    private String getExtension(String originalName) {
        if (originalName == null || !originalName.contains(".")) {
            return "";
        }
        return originalName.substring(originalName.lastIndexOf("."));
    }
}

----
package com.skrrrrr.harudam.file;

import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Configuration;

/**
 * 파일 저장소 관련 설정을 활성화하는 Config 클래스.
 * FileStorageProperties 를 Bean 으로 등록해주어야
 * 다른 서비스에서 @Autowired 로 사용 가능하다.
 */
@Configuration
@EnableConfigurationProperties(FileStorageProperties.class)
public class StorageConfig {
    // 별도의 Bean 정의 없이 Properties 클래스만 활성화한다.
}

